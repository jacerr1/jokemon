package pokemon.engine; import pokemon.core.*;import pokemon.interactive.Player; public class Battle { private Player p; private Pokemon opponent, player; private byte pokemonSlot; private boolean running; /** * Creates a Battle object. * @param p <code>Player</code> participating in the <code>Battle</code>. * @param opponent <code>Pokemon</code> battling against the <code>Player</code>. */ public Battle(Player p, Pokemon opponent) { this.p = p; this.opponent = opponent; this.running = true; pokemonSlot = 0; player = p.getParty()[pokemonSlot]; } /** * Checks to see if an array of <code>Move</code>'s contains a certain <code>Move</code>. * @param moves * @param m * @return */ private boolean containsMove(Move[] moves, Move m) { for(Move move : moves) { if(move == m) { return true; } } return false; } public static boolean applyStatus(final Move m, final Pokemon p) { final Status s = m.getStatusEffect(); for(int i = 0; i < p.getStatus().length; i++) { if(s.ordinal() == i) { p.getStatus()[i] = true; return true; } } return false; } /** * @param m * @return */ public String useMove(final Move m) { //If the moveSet doesn't have the move passed in, don't use the move if(!containsMove(player.getMoveSet(), m)) { return player.getName() + " does not know how to use " + m.getName() + "."; } //TODO Make the randomization prioritize Supereffective moves Move opponentMove = opponent.getMoveSet()[(byte)(Math.random() * opponent.getMoveSet().length)]; //short playerDamage = calculateDamage(player, m, opponent), opponentDamage = calculateDamage(opponent, opponentMove, player); if(player.getInBattleStat(Stat.SPEED) >= opponent.getInBattleStat(Stat.SPEED)) { //Player is faster OR the speeds are equal return useMoveInOrder(player, m, opponent, opponentMove); } else { //Opponent is faster return useMoveInOrder(opponent, opponentMove, player, m); } } private String useMoveInOrder(Pokemon first, Move firstMove, Pokemon second, Move secondMove) { String str = first.getName() + " used " + firstMove.getName() + "!"; short firstDamage = calculateDamage(first, firstMove, second), secondDamage = calculateDamage(second, secondMove, first); if((byte)(Math.random() * 100) + 1 <= firstMove.getAccuracy()) { str += "\n" + first.getName() + " deals " + firstDamage + " damage to " + second.getName() + "!"; second.takeDamage(firstDamage); float f = typeEffectiveness(second, firstMove); if(f == 0) { str += "\nIt has no effect on " + second.getName() + "."; } else if(f < 1) { str += "\nIt's not very effective"; } else if(f > 1) { str += "\nIt's Super Effective!"; } } else { str += "\nbut it missed..."; } if(second.isFainted()) { str = str + "\n" + second.getName() + " fainted!"; if(first.equals(player)) { str += "\n" + first.getName() + " gained " + calcExp(first, second) + " exp!"; first.addExp(calcExp(first, second)); str += "\n" + first.levelUp(); } else { running = false; second.revive(); } return str + "\n"; } str += "\n" + second.getName() + 
